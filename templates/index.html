<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice-Enabled Form</title>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 10px;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
        }

        /* Voice Control Section */
        .voice-control {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 30px;
            border-radius: 10px;
            margin-bottom: 25px;
            text-align: center;
            color: white;
        }

        .record-btn {
            background: white;
            color: #667eea;
            border: none;
            padding: 18px 40px;
            font-size: 18px;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 10px;
        }

        .record-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }

        .record-btn.recording {
            background: #dc3545;
            color: white;
            animation: pulse 1.5s infinite;
        }

        .record-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        @keyframes pulse {

            0%,
            100% {
                box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.7);
            }

            50% {
                box-shadow: 0 0 0 15px rgba(220, 53, 69, 0);
            }
        }

        .voice-hint {
            margin-top: 15px;
            font-size: 14px;
            opacity: 0.9;
        }

        /* Status/Progress Section */
        .status-section {
            margin-bottom: 20px;
        }

        .status {
            padding: 15px 20px;
            border-radius: 8px;
            font-size: 15px;
            display: none;
        }

        .status.show {
            display: block;
        }

        .status.info {
            background: #e3f2fd;
            color: #1565c0;
            border-left: 4px solid #1565c0;
        }

        .status.success {
            background: #e8f5e9;
            color: #2e7d32;
            border-left: 4px solid #2e7d32;
        }

        .status.warning {
            background: #fff3e0;
            color: #ef6c00;
            border-left: 4px solid #ef6c00;
        }

        .status.error {
            background: #ffebee;
            color: #c62828;
            border-left: 4px solid #c62828;
        }

        /* Progress Steps */
        .progress-steps {
            display: flex;
            justify-content: space-between;
            margin-bottom: 25px;
            padding: 0 10px;
        }

        .step {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex: 1;
            position: relative;
        }

        .step:not(:last-child)::after {
            content: '';
            position: absolute;
            top: 15px;
            left: 60%;
            width: 80%;
            height: 2px;
            background: #ddd;
        }

        .step.active:not(:last-child)::after,
        .step.completed:not(:last-child)::after {
            background: #667eea;
        }

        .step-icon {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: #ddd;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            margin-bottom: 5px;
            z-index: 1;
        }

        .step.active .step-icon {
            background: #667eea;
            color: white;
        }

        .step.completed .step-icon {
            background: #28a745;
            color: white;
        }

        .step-label {
            font-size: 12px;
            color: #666;
            text-align: center;
        }

        .step.active .step-label {
            color: #667eea;
            font-weight: bold;
        }

        /* Form Section */
        .form-section {
            margin-bottom: 25px;
        }

        .form-field {
            margin-bottom: 18px;
            position: relative;
        }

        label {
            display: block;
            margin-bottom: 6px;
            font-weight: 600;
            color: #444;
        }

        .field-wrapper {
            position: relative;
        }

        input[type="text"],
        input[type="email"],
        input[type="tel"] {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        input:focus {
            outline: none;
            border-color: #667eea;
        }

        /* Field States */
        .form-field.filled input {
            border-color: #28a745;
            background: #f8fff8;
        }

        .form-field.filled::after {
            content: 'âœ“';
            position: absolute;
            right: 12px;
            top: 38px;
            color: #28a745;
            font-weight: bold;
        }

        .form-field.missing input {
            border-color: #ef6c00;
            background: #fff8e1;
            animation: highlight-pulse 2s infinite;
        }

        .form-field.prompting input {
            border-color: #667eea;
            background: #f3e5f5;
            animation: highlight-pulse 1.5s infinite;
        }

        @keyframes highlight-pulse {

            0%,
            100% {
                box-shadow: 0 0 0 0 rgba(103, 126, 234, 0.4);
            }

            50% {
                box-shadow: 0 0 0 8px rgba(103, 126, 234, 0);
            }
        }

        /* Missing Field Prompt */
        .field-prompt {
            display: none;
            margin-top: 8px;
            padding: 12px 15px;
            background: #f3e5f5;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .field-prompt.show {
            display: block;
        }

        .field-prompt p {
            margin: 0 0 10px 0;
            color: #5e35b1;
            font-weight: 500;
        }

        .prompt-actions {
            display: flex;
            gap: 10px;
        }

        .prompt-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .prompt-btn.voice {
            background: #667eea;
            color: white;
        }

        .prompt-btn.skip {
            background: #e0e0e0;
            color: #666;
        }

        .prompt-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        /* Completion Message */
        .completion {
            display: none;
            text-align: center;
            padding: 30px;
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            border-radius: 10px;
            color: white;
            margin-top: 20px;
        }

        .completion.show {
            display: block;
        }

        .completion h2 {
            margin: 0 0 10px 0;
        }

        .completion p {
            margin: 0;
            opacity: 0.9;
        }

        /* Reset Button */
        .reset-btn {
            display: block;
            margin: 20px auto 0;
            padding: 10px 25px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        .reset-btn:hover {
            background: #5a6268;
        }

        /* Transcript Preview */
        .transcript-preview {
            display: none;
            margin-top: 15px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            font-style: italic;
        }

        .transcript-preview.show {
            display: block;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>Voice-Enabled Form</h1>
        <p class="subtitle">Speak naturally to fill out the form</p>

        <!-- Progress Steps -->
        <div class="progress-steps">
            <div class="step" id="step-record">
                <div class="step-icon">1</div>
                <div class="step-label">Record</div>
            </div>
            <div class="step" id="step-process">
                <div class="step-icon">2</div>
                <div class="step-label">Process</div>
            </div>
            <div class="step" id="step-fill">
                <div class="step-icon">3</div>
                <div class="step-label">Fill Fields</div>
            </div>
            <div class="step" id="step-complete">
                <div class="step-icon">4</div>
                <div class="step-label">Complete</div>
            </div>
        </div>

        <!-- Voice Control -->
        <div class="voice-control">
            <button class="record-btn" id="recordBtn" onclick="startRecording()">
                <span id="recordIcon">ðŸŽ¤</span>
                <span id="recordText">Start Recording</span>
            </button>
            <div class="voice-hint" id="voiceHint">
                Say something like: "My name is John Smith, email john@example.com, phone 555-123-4567, address 123 Main
                Street"
            </div>
            <div class="transcript-preview" id="transcriptPreview"></div>
        </div>

        <!-- Status Section -->
        <div class="status-section">
            <div class="status" id="status"></div>
        </div>

        <!-- Form Section -->
        <div class="form-section">
            <div class="form-field" id="field-name">
                <label for="name">Full Name</label>
                <div class="field-wrapper">
                    <input type="text" id="name" name="name" placeholder="Your full name">
                </div>
                <div class="field-prompt" id="prompt-name">
                    <p>ðŸŽ¤ Please say your <strong>name</strong></p>
                    <div class="prompt-actions">
                        <button class="prompt-btn voice" onclick="recordForField('name')">ðŸŽ¤ Speak</button>
                        <button class="prompt-btn skip" onclick="skipField('name')">Skip</button>
                    </div>
                </div>
            </div>

            <div class="form-field" id="field-email">
                <label for="email">Email Address</label>
                <div class="field-wrapper">
                    <input type="email" id="email" name="email" placeholder="your.email@example.com">
                </div>
                <div class="field-prompt" id="prompt-email">
                    <p>ðŸŽ¤ Please say your <strong>email address</strong></p>
                    <div class="prompt-actions">
                        <button class="prompt-btn voice" onclick="recordForField('email')">ðŸŽ¤ Speak</button>
                        <button class="prompt-btn skip" onclick="skipField('email')">Skip</button>
                    </div>
                </div>
            </div>

            <div class="form-field" id="field-phone">
                <label for="phone">Phone Number</label>
                <div class="field-wrapper">
                    <input type="tel" id="phone" name="phone" placeholder="555-123-4567">
                </div>
                <div class="field-prompt" id="prompt-phone">
                    <p>ðŸŽ¤ Please say your <strong>phone number</strong></p>
                    <div class="prompt-actions">
                        <button class="prompt-btn voice" onclick="recordForField('phone')">ðŸŽ¤ Speak</button>
                        <button class="prompt-btn skip" onclick="skipField('phone')">Skip</button>
                    </div>
                </div>
            </div>

            <div class="form-field" id="field-address">
                <label for="address">Address</label>
                <div class="field-wrapper">
                    <input type="text" id="address" name="address" placeholder="Your street address">
                </div>
                <div class="field-prompt" id="prompt-address">
                    <p>ðŸŽ¤ Please say your <strong>address</strong></p>
                    <div class="prompt-actions">
                        <button class="prompt-btn voice" onclick="recordForField('address')">ðŸŽ¤ Speak</button>
                        <button class="prompt-btn skip" onclick="skipField('address')">Skip</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Completion Message -->
        <div class="completion" id="completion">
            <h2>âœ… Form Complete!</h2>
            <p>All fields have been filled successfully.</p>
        </div>

        <button class="reset-btn" onclick="resetForm()">ðŸ”„ Reset Form</button>
    </div>

    <script>
        // ============================================
        // State Management
        // ============================================
        const FIELDS = ['name', 'email', 'phone', 'address'];
        let isRecording = false;
        let mediaRecorder = null;
        let audioChunks = [];
        let stream = null;
        let audioContext = null;
        let analyser = null;
        let silenceTimer = null;
        let recordingStartTime = 0;
        let currentMode = 'all'; // 'all' or 'single'
        let currentPromptField = null;
        let missingFieldsQueue = [];

        // Silence detection settings
        const SILENCE_THRESHOLD = 0.08;
        const SILENCE_DELAY = 1500; // 1.5 seconds of silence
        const MIN_RECORDING_TIME = 800;

        // ============================================
        // UI Helpers
        // ============================================
        function showStatus(message, type = 'info') {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status show ${type}`;
        }

        function hideStatus() {
            document.getElementById('status').className = 'status';
        }

        function setStep(stepId) {
            document.querySelectorAll('.step').forEach(s => {
                s.classList.remove('active', 'completed');
            });

            const steps = ['step-record', 'step-process', 'step-fill', 'step-complete'];
            const currentIndex = steps.indexOf(stepId);

            steps.forEach((step, index) => {
                const el = document.getElementById(step);
                if (index < currentIndex) {
                    el.classList.add('completed');
                } else if (index === currentIndex) {
                    el.classList.add('active');
                }
            });
        }

        function updateRecordButton(recording) {
            const btn = document.getElementById('recordBtn');
            const icon = document.getElementById('recordIcon');
            const text = document.getElementById('recordText');

            if (recording) {
                btn.classList.add('recording');
                icon.textContent = 'â¹ï¸';
                text.textContent = 'Stop Recording';
            } else {
                btn.classList.remove('recording');
                icon.textContent = 'ðŸŽ¤';
                text.textContent = 'Start Recording';
            }
        }

        function setFieldState(fieldId, state) {
            const field = document.getElementById(`field-${fieldId}`);
            field.classList.remove('filled', 'missing', 'prompting');
            if (state) {
                field.classList.add(state);
            }
        }

        function showFieldPrompt(fieldId) {
            // Hide all prompts first
            document.querySelectorAll('.field-prompt').forEach(p => p.classList.remove('show'));

            // Show specific prompt
            const prompt = document.getElementById(`prompt-${fieldId}`);
            if (prompt) {
                prompt.classList.add('show');
                setFieldState(fieldId, 'prompting');
                document.getElementById(fieldId).focus();
            }
        }

        function hideFieldPrompt(fieldId) {
            const prompt = document.getElementById(`prompt-${fieldId}`);
            if (prompt) {
                prompt.classList.remove('show');
            }
        }

        function showCompletion() {
            document.getElementById('completion').classList.add('show');
            setStep('step-complete');
            showStatus('All fields have been captured!', 'success');
        }

        // ============================================
        // Recording Functions
        // ============================================
        async function startRecording() {
            if (isRecording) {
                stopRecording();
                return;
            }

            try {
                currentMode = 'all';
                setStep('step-record');
                showStatus('ðŸŽ¤ Listening... speak naturally about all your information', 'info');

                stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        sampleRate: 16000,
                        channelCount: 1,
                        echoCancellation: true,
                        noiseSuppression: true
                    }
                });

                // Set up audio analysis
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                const source = audioContext.createMediaStreamSource(stream);
                source.connect(analyser);
                analyser.fftSize = 512;

                mediaRecorder = new MediaRecorder(stream, {
                    mimeType: 'audio/webm;codecs=opus'
                });

                audioChunks = [];
                isRecording = true;
                recordingStartTime = Date.now();

                mediaRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) audioChunks.push(e.data);
                };

                mediaRecorder.onstop = async () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    const duration = Date.now() - recordingStartTime;

                    if (audioBlob.size > 1000 && duration > MIN_RECORDING_TIME) {
                        if (currentMode === 'all') {
                            await processFullRecording(audioBlob);
                        } else {
                            await processFieldRecording(audioBlob, currentPromptField);
                        }
                    } else {
                        showStatus('Recording too short. Please try again.', 'warning');
                    }

                    cleanupRecording();
                };

                mediaRecorder.start(100);
                updateRecordButton(true);

                // Start silence detection
                detectSilence();

            } catch (error) {
                console.error('Recording failed:', error);
                showStatus('Microphone access denied. Please allow microphone access.', 'error');
                cleanupRecording();
            }
        }

        function stopRecording() {
            if (mediaRecorder && isRecording) {
                if (silenceTimer) {
                    clearTimeout(silenceTimer);
                    silenceTimer = null;
                }
                mediaRecorder.stop();
                isRecording = false;
                updateRecordButton(false);
            }
        }

        function cleanupRecording() {
            isRecording = false;
            updateRecordButton(false);

            if (stream) {
                stream.getTracks().forEach(t => t.stop());
                stream = null;
            }
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }
            if (silenceTimer) {
                clearTimeout(silenceTimer);
                silenceTimer = null;
            }
        }

        let lastSoundTime = 0;

        function detectSilence() {
            if (!isRecording || !analyser) return;

            const dataArray = new Uint8Array(analyser.frequencyBinCount);
            analyser.getByteFrequencyData(dataArray);

            const average = dataArray.reduce((a, b) => a + b, 0) / dataArray.length / 255;
            const now = Date.now();

            if (average > SILENCE_THRESHOLD) {
                lastSoundTime = now;
            }

            const silenceDuration = now - lastSoundTime;
            const recordingDuration = now - recordingStartTime;

            if (silenceDuration > SILENCE_DELAY && recordingDuration > MIN_RECORDING_TIME) {
                console.log('Silence detected, stopping recording');
                showStatus('ðŸ”„ Processing your speech...', 'info');
                stopRecording();
                return;
            }

            // Visual feedback
            if (silenceDuration > 500 && silenceDuration < SILENCE_DELAY) {
                const remaining = Math.ceil((SILENCE_DELAY - silenceDuration) / 1000);
                showStatus(`ðŸŽ¤ Listening... (auto-stop in ${remaining}s of silence)`, 'info');
            }

            requestAnimationFrame(detectSilence);
        }

        // ============================================
        // Processing Functions
        // ============================================
        async function processFullRecording(audioBlob) {
            setStep('step-process');
            showStatus('ðŸ”„ Transcribing and extracting fields...', 'info');

            const formData = new FormData();
            formData.append('audio', audioBlob, 'recording.webm');

            try {
                const response = await fetch('/transcribe', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();
                console.log('Transcription result:', result);

                if (response.ok && result.success) {
                    // Show transcript
                    const preview = document.getElementById('transcriptPreview');
                    preview.textContent = `"${result.transcript}"`;
                    preview.classList.add('show');

                    // Fill fields
                    setStep('step-fill');
                    fillFieldsFromResult(result.form_data || {});

                    // Check for missing fields
                    const missing = result.missing_fields || findMissingFields();

                    if (missing.length > 0) {
                        missingFieldsQueue = [...missing];
                        showStatus(`Filled ${FIELDS.length - missing.length} of ${FIELDS.length} fields. Let's capture the rest.`, 'warning');
                        promptNextMissingField();
                    } else {
                        showCompletion();
                    }
                } else {
                    showStatus(result.error || 'Failed to process speech', 'error');
                }
            } catch (error) {
                console.error('Processing error:', error);
                showStatus('Error processing recording. Please try again.', 'error');
            }
        }

        function fillFieldsFromResult(formData) {
            FIELDS.forEach(field => {
                const value = formData[field];
                if (value && value.trim()) {
                    document.getElementById(field).value = value.trim();
                    setFieldState(field, 'filled');
                }
            });
        }

        function findMissingFields() {
            return FIELDS.filter(field => {
                const value = document.getElementById(field).value;
                return !value || !value.trim();
            });
        }

        // ============================================
        // Missing Field Prompts
        // ============================================
        function promptNextMissingField() {
            if (missingFieldsQueue.length === 0) {
                // All fields complete
                showCompletion();
                return;
            }

            const fieldId = missingFieldsQueue[0];
            currentPromptField = fieldId;

            // Mark remaining as missing
            missingFieldsQueue.forEach(f => setFieldState(f, 'missing'));

            // Show prompt for first missing field
            showFieldPrompt(fieldId);
            showStatus(`Please provide your ${fieldId}`, 'info');
        }

        async function recordForField(fieldId) {
            currentMode = 'single';
            currentPromptField = fieldId;

            hideFieldPrompt(fieldId);
            showStatus(`ðŸŽ¤ Listening for your ${fieldId}...`, 'info');

            try {
                stream = await navigator.mediaDevices.getUserMedia({
                    audio: { echoCancellation: true, noiseSuppression: true }
                });

                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                const source = audioContext.createMediaStreamSource(stream);
                source.connect(analyser);
                analyser.fftSize = 512;

                mediaRecorder = new MediaRecorder(stream, {
                    mimeType: 'audio/webm;codecs=opus'
                });

                audioChunks = [];
                isRecording = true;
                recordingStartTime = Date.now();
                lastSoundTime = Date.now();

                mediaRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) audioChunks.push(e.data);
                };

                mediaRecorder.onstop = async () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    await processFieldRecording(audioBlob, currentPromptField);
                    cleanupRecording();
                };

                mediaRecorder.start(100);
                detectSilence();

            } catch (error) {
                console.error('Field recording failed:', error);
                showStatus('Microphone error. Please try again.', 'error');
                showFieldPrompt(fieldId);
            }
        }

        async function processFieldRecording(audioBlob, fieldId) {
            showStatus(`ðŸ”„ Processing ${fieldId}...`, 'info');

            const formData = new FormData();
            formData.append('audio', audioBlob, 'recording.webm');

            try {
                const response = await fetch('/transcribe_simple', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();
                console.log('Field transcription:', result);

                if (response.ok && result.success && result.transcript) {
                    const input = document.getElementById(fieldId);
                    input.value = result.transcript.trim();
                    setFieldState(fieldId, 'filled');
                    hideFieldPrompt(fieldId);

                    // Remove from queue and continue
                    missingFieldsQueue = missingFieldsQueue.filter(f => f !== fieldId);

                    if (missingFieldsQueue.length > 0) {
                        showStatus(`Got it! ${missingFieldsQueue.length} field(s) remaining.`, 'success');
                        setTimeout(() => promptNextMissingField(), 500);
                    } else {
                        showCompletion();
                    }
                } else {
                    showStatus('Could not capture that. Please try again.', 'warning');
                    showFieldPrompt(fieldId);
                }
            } catch (error) {
                console.error('Field processing error:', error);
                showStatus('Error processing. Please try again.', 'error');
                showFieldPrompt(fieldId);
            }
        }

        function skipField(fieldId) {
            hideFieldPrompt(fieldId);
            setFieldState(fieldId, '');

            // Remove from queue
            missingFieldsQueue = missingFieldsQueue.filter(f => f !== fieldId);

            if (missingFieldsQueue.length > 0) {
                promptNextMissingField();
            } else {
                // Check if any fields have values
                const filledCount = FIELDS.filter(f => document.getElementById(f).value.trim()).length;
                if (filledCount > 0) {
                    showCompletion();
                } else {
                    showStatus('Form is empty. Click "Start Recording" to try again.', 'warning');
                    setStep('step-record');
                }
            }
        }

        // ============================================
        // Reset Function
        // ============================================
        function resetForm() {
            // Clear all inputs
            FIELDS.forEach(field => {
                document.getElementById(field).value = '';
                setFieldState(field, '');
                hideFieldPrompt(field);
            });

            // Reset state
            missingFieldsQueue = [];
            currentPromptField = null;
            currentMode = 'all';

            // Reset UI
            document.getElementById('transcriptPreview').classList.remove('show');
            document.getElementById('completion').classList.remove('show');
            hideStatus();
            setStep('step-record');

            cleanupRecording();
        }

        // ============================================
        // Manual Input Support
        // ============================================
        FIELDS.forEach(field => {
            const input = document.getElementById(field);
            input.addEventListener('input', () => {
                if (input.value.trim()) {
                    setFieldState(field, 'filled');

                    // If this was the prompted field, move to next
                    if (currentPromptField === field) {
                        hideFieldPrompt(field);
                        missingFieldsQueue = missingFieldsQueue.filter(f => f !== field);

                        if (missingFieldsQueue.length > 0) {
                            setTimeout(() => promptNextMissingField(), 300);
                        } else {
                            showCompletion();
                        }
                    }
                } else {
                    setFieldState(field, '');
                }
            });
        });

        // Initialize
        setStep('step-record');
    </script>
</body>

</html>