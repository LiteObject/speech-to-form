<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice-Enabled Form</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 10px;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
        }

        /* Voice Control Section */
        .voice-control {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 30px;
            border-radius: 10px;
            margin-bottom: 25px;
            text-align: center;
            color: white;
        }

        .record-btn {
            background: white;
            color: #667eea;
            border: none;
            padding: 18px 40px;
            font-size: 18px;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 10px;
        }

        .record-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }

        .record-btn.recording {
            background: #dc3545;
            color: white;
            animation: pulse 1.5s infinite;
        }

        .record-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        @keyframes pulse {

            0%,
            100% {
                box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.7);
            }

            50% {
                box-shadow: 0 0 0 15px rgba(220, 53, 69, 0);
            }
        }

        .voice-hint {
            margin-top: 15px;
            font-size: 14px;
            opacity: 0.9;
        }

        /* Status/Progress Section */
        .status-section {
            margin-bottom: 20px;
        }

        .status {
            padding: 15px 20px;
            border-radius: 8px;
            font-size: 15px;
            display: none;
        }

        .status.show {
            display: block;
        }

        .status.info {
            background: #e3f2fd;
            color: #1565c0;
        }

        .status.success {
            background: #e8f5e9;
            color: #2e7d32;
        }

        .status.warning {
            background: #fff3e0;
            color: #ef6c00;
        }

        .status.error {
            background: #ffebee;
            color: #c62828;
        }

        /* Progress Steps */
        .progress-steps {
            display: flex;
            justify-content: space-between;
            margin-bottom: 25px;
            padding: 0 10px;
        }

        .step {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex: 1;
            position: relative;
        }

        .step:not(:last-child)::after {
            content: '';
            position: absolute;
            top: 15px;
            left: 60%;
            width: 80%;
            height: 2px;
            background: #ddd;
        }

        .step.active:not(:last-child)::after,
        .step.completed:not(:last-child)::after {
            background: #667eea;
        }

        .step-icon {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: #ddd;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            margin-bottom: 5px;
            z-index: 1;
        }

        .step.active .step-icon {
            background: #667eea;
            color: white;
        }

        .step.completed .step-icon {
            background: #28a745;
            color: white;
        }

        .step-label {
            font-size: 12px;
            color: #666;
            text-align: center;
        }

        .step.active .step-label {
            color: #667eea;
            font-weight: bold;
        }

        /* Form Section */
        .form-section {
            margin-bottom: 25px;
        }

        .form-field {
            margin-bottom: 18px;
            position: relative;
        }

        label {
            display: block;
            margin-bottom: 6px;
            font-weight: 600;
            color: #444;
        }

        .field-wrapper {
            position: relative;
        }

        input[type="text"],
        input[type="email"],
        input[type="tel"] {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        input:focus {
            outline: none;
            border-color: #667eea;
        }

        /* Field States */
        .form-field.filled input {
            border-color: #28a745;
            background: #f8fff8;
        }

        .form-field.filled::after {
            content: 'âœ“';
            position: absolute;
            right: 12px;
            top: 38px;
            color: #28a745;
            font-weight: bold;
        }

        .form-field.missing input {
            border-color: #ef6c00;
            background: #fff8e1;
            animation: highlight-pulse 2s infinite;
        }

        .form-field.low-confidence input {
            border-color: #ffc107;
            background: #fffde7;
        }

        .form-field.prompting input {
            border-color: #667eea;
            background: #f3e5f5;
            animation: highlight-pulse 1.5s infinite;
        }

        @keyframes highlight-pulse {

            0%,
            100% {
                box-shadow: 0 0 0 0 rgba(103, 126, 234, 0.4);
            }

            50% {
                box-shadow: 0 0 0 8px rgba(103, 126, 234, 0);
            }
        }

        /* Confidence Indicator */
        .confidence-indicator {
            display: none;
            align-items: center;
            gap: 6px;
            margin-top: 6px;
            font-size: 12px;
        }

        .confidence-indicator.show {
            display: flex;
        }

        .confidence-bar {
            flex: 1;
            height: 4px;
            background: #e0e0e0;
            border-radius: 2px;
            overflow: hidden;
            max-width: 100px;
        }

        .confidence-fill {
            height: 100%;
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        .confidence-fill.high {
            background: #28a745;
        }

        .confidence-fill.medium {
            background: #ffc107;
        }

        .confidence-fill.low {
            background: #dc3545;
        }

        .confidence-text {
            color: #666;
        }

        .rerecord-btn {
            padding: 4px 10px;
            border: none;
            background: #ffc107;
            color: #333;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .rerecord-btn:hover {
            background: #e0a800;
            transform: scale(1.05);
        }

        /* Missing Field Prompt */
        .field-prompt {
            display: none;
            margin-top: 8px;
            padding: 12px 15px;
            background: #f3e5f5;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .field-prompt.show {
            display: block;
        }

        .field-prompt p {
            margin: 0 0 10px 0;
            color: #5e35b1;
            font-weight: 500;
        }

        .prompt-actions {
            display: flex;
            gap: 10px;
        }

        .prompt-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .prompt-btn.voice {
            background: #667eea;
            color: white;
        }

        .prompt-btn.skip {
            background: #e0e0e0;
            color: #666;
        }

        .prompt-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        /* Completion Message */
        .completion {
            display: none;
            text-align: center;
            padding: 30px;
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            border-radius: 10px;
            color: white;
            margin-top: 20px;
        }

        .completion.show {
            display: block;
        }

        .completion h2 {
            margin: 0 0 10px 0;
        }

        .completion p {
            margin: 0;
            opacity: 0.9;
        }

        /* Reset Button */
        .reset-btn {
            display: block;
            margin: 20px auto 0;
            padding: 10px 25px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        .reset-btn:hover {
            background: #5a6268;
        }

        /* Transcript Preview */
        .transcript-preview {
            display: none;
            margin-top: 15px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            font-style: italic;
        }

        .transcript-preview.show {
            display: block;
        }

        /* Processing Mode Selector */
        .mode-selector {
            background: #f8f9fa;
            padding: 15px 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #e0e0e0;
        }

        .mode-selector-title {
            font-weight: 600;
            color: #333;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .mode-options {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .mode-option {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            cursor: pointer;
            padding: 10px 15px;
            border-radius: 6px;
            border: 2px solid #e0e0e0;
            background: white;
            flex: 1;
            min-width: 200px;
            transition: all 0.2s;
        }

        .mode-option:hover {
            border-color: #667eea;
        }

        .mode-option.selected {
            border-color: #667eea;
            background: #f3e8ff;
        }

        .mode-option input[type="radio"] {
            margin-top: 3px;
        }

        .mode-option-content {
            flex: 1;
        }

        .mode-option-label {
            font-weight: 600;
            color: #333;
            display: block;
            margin-bottom: 2px;
        }

        .mode-option-desc {
            font-size: 12px;
            color: #666;
            line-height: 1.4;
        }

        .mode-option-badge {
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: 600;
            margin-left: 5px;
        }

        .badge-fast {
            background: #d4edda;
            color: #155724;
        }

        .badge-accurate {
            background: #cce5ff;
            color: #004085;
        }

        .badge-local {
            background: #fff3cd;
            color: #856404;
        }

        /* Backend selector (sub-options for single-stage) */
        .backend-selector {
            margin-top: 10px;
            padding: 12px 15px;
            background: #f0f4ff;
            border-radius: 6px;
            border: 1px solid #d0d9ff;
            display: none;
        }

        .backend-selector.show {
            display: block;
        }

        .backend-selector-title {
            font-size: 12px;
            font-weight: 600;
            color: #4a5568;
            margin-bottom: 8px;
        }

        .backend-options {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .backend-option {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            padding: 6px 12px;
            border-radius: 4px;
            border: 1px solid #d0d9ff;
            background: white;
            font-size: 13px;
            transition: all 0.2s;
        }

        .backend-option:hover {
            border-color: #667eea;
        }

        .backend-option.selected {
            border-color: #667eea;
            background: #e8f0fe;
        }

        .backend-option input[type="radio"] {
            margin: 0;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>Voice-Enabled Form</h1>
        <p class="subtitle">Speak naturally to fill out the form</p>

        <!-- Processing Mode Selector -->
        <div class="mode-selector">
            <div class="mode-selector-title">Processing Mode</div>
            <div class="mode-options">
                <label class="mode-option selected" id="mode-two-stage" onclick="selectMode('two-stage')">
                    <input type="radio" name="processing-mode" value="two-stage" checked>
                    <div class="mode-option-content">
                        <span class="mode-option-label">
                            Two-Stage (Local)
                            <span class="mode-option-badge badge-fast">FAST</span>
                        </span>
                        <span class="mode-option-desc">Whisper transcription + local extraction. Works offline, instant
                            parsing.</span>
                    </div>
                </label>
                <label class="mode-option" id="mode-single-stage" onclick="selectMode('single-stage')">
                    <input type="radio" name="processing-mode" value="single-stage">
                    <div class="mode-option-content">
                        <span class="mode-option-label">
                            Single-Stage
                            <span class="mode-option-badge badge-accurate">ACCURATE</span>
                        </span>
                        <span class="mode-option-desc">Audio processed directly by LLM for transcription +
                            extraction.</span>
                    </div>
                </label>
            </div>

            <!-- Backend selector (shown when single-stage is selected) -->
            <div class="backend-selector" id="backendSelector">
                <div class="backend-selector-title">Select Backend:</div>
                <div class="backend-options">
                    <label class="backend-option selected" id="backend-openai" onclick="selectBackend('openai')">
                        <input type="radio" name="backend" value="openai" checked>
                        <span>OpenAI GPT-4o</span>
                        <span class="mode-option-badge badge-accurate">CLOUD</span>
                    </label>
                    <label class="backend-option" id="backend-ollama" onclick="selectBackend('ollama')">
                        <input type="radio" name="backend" value="ollama">
                        <span>Ollama (Whisper + LLM)</span>
                        <span class="mode-option-badge badge-local">LOCAL</span>
                    </label>
                    <label class="backend-option" id="backend-vllm" onclick="selectBackend('vllm')">
                        <input type="radio" name="backend" value="vllm">
                        <span>vLLM (Ultravox)</span>
                        <span class="mode-option-badge badge-local">LOCAL</span>
                    </label>
                </div>
            </div>
        </div>

        <!-- Progress Steps -->
        <div class="progress-steps">
            <div class="step" id="step-record">
                <div class="step-icon">1</div>
                <div class="step-label">Record</div>
            </div>
            <div class="step" id="step-process">
                <div class="step-icon">2</div>
                <div class="step-label">Process</div>
            </div>
            <div class="step" id="step-fill">
                <div class="step-icon">3</div>
                <div class="step-label">Fill Fields</div>
            </div>
            <div class="step" id="step-complete">
                <div class="step-icon">4</div>
                <div class="step-label">Complete</div>
            </div>
        </div>

        <!-- Voice Control -->
        <div class="voice-control">
            <button class="record-btn" id="recordBtn" onclick="startRecording()">
                <span id="recordIcon">ðŸŽ¤</span>
                <span id="recordText">Start Recording</span>
            </button>
            <div class="voice-hint" id="voiceHint">
                Say all your information, then click Stop. Example: "My name is John Smith, email john@example.com,
                phone 555-123-4567, address 123 Main Street"
            </div>
            <div class="transcript-preview" id="transcriptPreview"></div>
        </div>

        <!-- Status Section -->
        <div class="status-section">
            <div class="status" id="status"></div>
        </div>

        <!-- Form Section -->
        <div class="form-section">
            <div class="form-field" id="field-name">
                <label for="name">Full Name</label>
                <div class="field-wrapper">
                    <input type="text" id="name" name="name" placeholder="Your full name">
                </div>
                <div class="confidence-indicator" id="confidence-name">
                    <div class="confidence-bar">
                        <div class="confidence-fill" id="confidence-fill-name"></div>
                    </div>
                    <span class="confidence-text" id="confidence-text-name"></span>
                    <button class="rerecord-btn" onclick="recordForField('name')">ðŸŽ¤ Re-record</button>
                </div>
            </div>

            <div class="form-field" id="field-email">
                <label for="email">Email Address</label>
                <div class="field-wrapper">
                    <input type="email" id="email" name="email" placeholder="your.email@example.com">
                </div>
                <div class="confidence-indicator" id="confidence-email">
                    <div class="confidence-bar">
                        <div class="confidence-fill" id="confidence-fill-email"></div>
                    </div>
                    <span class="confidence-text" id="confidence-text-email"></span>
                    <button class="rerecord-btn" onclick="recordForField('email')">ðŸŽ¤ Re-record</button>
                </div>
            </div>

            <div class="form-field" id="field-phone">
                <label for="phone">Phone Number</label>
                <div class="field-wrapper">
                    <input type="tel" id="phone" name="phone" placeholder="555-123-4567">
                </div>
                <div class="confidence-indicator" id="confidence-phone">
                    <div class="confidence-bar">
                        <div class="confidence-fill" id="confidence-fill-phone"></div>
                    </div>
                    <span class="confidence-text" id="confidence-text-phone"></span>
                    <button class="rerecord-btn" onclick="recordForField('phone')">ðŸŽ¤ Re-record</button>
                </div>
            </div>

            <div class="form-field" id="field-address">
                <label for="address">Address</label>
                <div class="field-wrapper">
                    <input type="text" id="address" name="address" placeholder="Your street address">
                </div>
                <div class="confidence-indicator" id="confidence-address">
                    <div class="confidence-bar">
                        <div class="confidence-fill" id="confidence-fill-address"></div>
                    </div>
                    <span class="confidence-text" id="confidence-text-address"></span>
                    <button class="rerecord-btn" onclick="recordForField('address')">ðŸŽ¤ Re-record</button>
                </div>
            </div>
        </div>

        <!-- Completion Message -->
        <div class="completion" id="completion">
            <h2>âœ… Form Complete!</h2>
            <p>All fields have been filled successfully.</p>
        </div>

        <button class="reset-btn" onclick="resetForm()">ðŸ”„ Reset Form</button>
    </div>

    <script>
        // ============================================
        // State Management
        // ============================================
        const FIELDS = ['name', 'email', 'phone', 'address'];
        let isRecording = false;
        let mediaRecorder = null;
        let audioChunks = [];
        let stream = null;
        let audioContext = null;
        let analyser = null;
        let silenceTimer = null;
        let recordingStartTime = 0;
        let currentMode = 'all'; // 'all' or 'single'
        let currentPromptField = null;
        let missingFieldsQueue = [];
        let processingMode = 'two-stage'; // 'two-stage' or 'single-stage'
        let selectedBackend = 'openai'; // 'openai', 'ollama', or 'vllm'

        // Socket.IO Initialization
        const socket = io();

        socket.on('connect', () => {
            console.log('Connected to WebSocket');
        });

        socket.on('transcription_update', (data) => {
            console.log('Real-time update:', data);

            // Update transcript preview
            const preview = document.getElementById('transcriptPreview');
            preview.textContent = `"${data.transcript}"`;
            preview.classList.add('show');

            // Update fields
            if (data.form_data) {
                fillFieldsFromResult(data.form_data, {});
            }
        });

        // Silence detection settings
        const SILENCE_THRESHOLD = 0.08;
        const SILENCE_DELAY = 1500; // 1.5 seconds of silence
        const MIN_RECORDING_TIME = 800;

        // ============================================
        // Mode Selection
        // ============================================
        function selectMode(mode) {
            processingMode = mode;

            // Update UI
            document.querySelectorAll('.mode-option').forEach(el => {
                el.classList.remove('selected');
            });
            document.getElementById(`mode-${mode}`).classList.add('selected');

            // Update radio button
            document.querySelector(`input[value="${mode}"]`).checked = true;

            // Show/hide backend selector
            const backendSelector = document.getElementById('backendSelector');
            if (mode === 'single-stage') {
                backendSelector.classList.add('show');
            } else {
                backendSelector.classList.remove('show');
            }

            // Update hint text based on mode and backend
            updateHintText();
        }

        function selectBackend(backend) {
            selectedBackend = backend;

            // Update UI
            document.querySelectorAll('.backend-option').forEach(el => {
                el.classList.remove('selected');
            });
            document.getElementById(`backend-${backend}`).classList.add('selected');

            // Update radio button
            document.querySelector(`input[value="${backend}"]`).checked = true;

            // Update hint text
            updateHintText();
        }

        function updateHintText() {
            const hint = document.getElementById('voiceHint');
            if (processingMode === 'single-stage') {
                const backendLabels = {
                    'openai': 'Audio sent directly to OpenAI GPT-4o (cloud).',
                    'ollama': 'Audio processed locally with Whisper + Ollama LLM.',
                    'vllm': 'Audio processed locally with vLLM Ultravox model.'
                };
                hint.textContent = 'Single-stage mode: ' + backendLabels[selectedBackend];
            } else {
                hint.textContent = 'Say all your information, then click Stop. Example: "My name is John Smith, email john@example.com, phone 555-123-4567, address 123 Main Street"';
            }
        }

        // ============================================
        // Text Normalization
        // ============================================
        function normalizeFieldValue(fieldId, value) {
            if (!value) return value;

            let normalized = value.trim();

            // Detect and combine spelled-out letters (e.g., "M O H A M M E D" â†’ "Mohammed")
            normalized = combineSpelledLetters(normalized);

            if (fieldId === 'email') {
                // Convert spoken email patterns to proper format
                normalized = normalized
                    .toLowerCase()
                    .replace(/\s+at\s+/gi, '@')
                    .replace(/\bat\b/gi, '@')
                    .replace(/\s+dot\s+/gi, '.')
                    .replace(/\bdot\b/gi, '.')
                    .replace(/\s+/g, '')  // Remove all spaces from email
                    .replace(/,/g, '.');   // Common misheard comma as dot
            }

            if (fieldId === 'phone') {
                // Clean up phone number - keep only digits and common separators
                normalized = normalized
                    .replace(/[oO]/g, '0')  // Common O for 0 mishearing
                    .replace(/\s+/g, '-')   // Replace spaces with dashes
                    .replace(/[^0-9\-\(\)\+]/g, ''); // Keep only valid phone chars
            }

            return normalized;
        }

        function combineSpelledLetters(text) {
            // Handle both space-separated and hyphen-separated spelled letters
            // e.g., "M O H A M M E D" or "M-O-H-A-M-M-E-D" â†’ "Mohammed"

            // First, normalize hyphens between single letters to spaces
            // Pattern: single letter, hyphen, single letter (repeated)
            let normalized = text.replace(/\b([a-zA-Z])-([a-zA-Z])-([a-zA-Z])(-[a-zA-Z])*\b/g, (match) => {
                return match.replace(/-/g, ' ');
            });

            // Now handle space-separated single letters (at least 3 consecutive)
            const spelledPattern = /\b([a-zA-Z])\s+([a-zA-Z])\s+([a-zA-Z])(\s+[a-zA-Z])*\b/g;

            return normalized.replace(spelledPattern, (match) => {
                // Check if this looks like spelled letters (all single chars separated by spaces)
                const letters = match.split(/\s+/);

                // Only combine if all parts are single letters
                if (letters.every(l => l.length === 1)) {
                    // Capitalize first letter, lowercase rest
                    const combined = letters.join('');
                    return combined.charAt(0).toUpperCase() + combined.slice(1).toLowerCase();
                }
                return match;
            });
        }

        // ============================================
        // UI Helpers
        // ============================================
        function showStatus(message, type = 'info') {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status show ${type}`;
        }

        function hideStatus() {
            document.getElementById('status').className = 'status';
        }

        function setStep(stepId) {
            document.querySelectorAll('.step').forEach(s => {
                s.classList.remove('active', 'completed');
            });

            const steps = ['step-record', 'step-process', 'step-fill', 'step-complete'];
            const currentIndex = steps.indexOf(stepId);

            steps.forEach((step, index) => {
                const el = document.getElementById(step);
                if (index < currentIndex) {
                    el.classList.add('completed');
                } else if (index === currentIndex) {
                    el.classList.add('active');
                }
            });
        }

        function updateRecordButton(recording) {
            const btn = document.getElementById('recordBtn');
            const icon = document.getElementById('recordIcon');
            const text = document.getElementById('recordText');

            if (recording) {
                btn.classList.add('recording');
                icon.textContent = 'â¹ï¸';
                text.textContent = 'Stop Recording';
            } else {
                btn.classList.remove('recording');
                icon.textContent = 'ðŸŽ¤';
                text.textContent = 'Start Recording';
            }
        }

        function setFieldState(fieldId, state) {
            const field = document.getElementById(`field-${fieldId}`);
            field.classList.remove('filled', 'missing', 'prompting', 'low-confidence');
            if (state) {
                field.classList.add(state);
            }
        }

        function showFieldPrompt(fieldId) {
            // Hide all prompts first
            document.querySelectorAll('.field-prompt').forEach(p => p.classList.remove('show'));

            // Show specific prompt
            const prompt = document.getElementById(`prompt-${fieldId}`);
            if (prompt) {
                prompt.classList.add('show');
                setFieldState(fieldId, 'prompting');
                document.getElementById(fieldId).focus();
            }
        }

        function hideFieldPrompt(fieldId) {
            const prompt = document.getElementById(`prompt-${fieldId}`);
            if (prompt) {
                prompt.classList.remove('show');
            }
        }

        function showCompletion() {
            document.getElementById('completion').classList.add('show');
            setStep('step-complete');
            showStatus('All fields have been captured!', 'success');
        }

        // ============================================
        // Recording Functions
        // ============================================
        async function startRecording() {
            if (isRecording) {
                stopRecording();
                return;
            }

            try {
                currentMode = 'all';
                setStep('step-record');
                showStatus('ðŸŽ¤ Listening... speak naturally about all your information', 'info');

                stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        sampleRate: 16000,
                        channelCount: 1,
                        echoCancellation: true,
                        noiseSuppression: true
                    }
                });

                // Set up audio analysis
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                const source = audioContext.createMediaStreamSource(stream);
                source.connect(analyser);
                analyser.fftSize = 512;

                mediaRecorder = new MediaRecorder(stream, {
                    mimeType: 'audio/webm;codecs=opus'
                });

                audioChunks = [];
                isRecording = true;
                recordingStartTime = Date.now();

                mediaRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) {
                        audioChunks.push(e.data);
                        // Send chunk to server for real-time processing
                        socket.emit('audio_chunk', e.data);
                    }
                };

                mediaRecorder.onstop = async () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    const duration = Date.now() - recordingStartTime;

                    if (audioBlob.size > 1000 && duration > MIN_RECORDING_TIME) {
                        if (currentMode === 'all') {
                            await processFullRecording(audioBlob);
                        } else {
                            await processFieldRecording(audioBlob, currentPromptField);
                        }
                    } else {
                        showStatus('Recording too short. Please try again.', 'warning');
                    }

                    cleanupRecording();
                };

                mediaRecorder.start(100);
                updateRecordButton(true);

                // Start silence detection
                detectSilence();

            } catch (error) {
                console.error('Recording failed:', error);
                showStatus('Microphone access denied. Please allow microphone access.', 'error');
                cleanupRecording();
            }
        }

        function stopRecording() {
            if (mediaRecorder && isRecording) {
                if (silenceTimer) {
                    clearTimeout(silenceTimer);
                    silenceTimer = null;
                }
                mediaRecorder.stop();
                isRecording = false;
                updateRecordButton(false);
            }
        }

        function cleanupRecording() {
            isRecording = false;
            updateRecordButton(false);

            if (stream) {
                stream.getTracks().forEach(t => t.stop());
                stream = null;
            }
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }
            if (silenceTimer) {
                clearTimeout(silenceTimer);
                silenceTimer = null;
            }
        }

        let lastSoundTime = 0;

        function detectSilence() {
            if (!isRecording || !analyser) return;

            const dataArray = new Uint8Array(analyser.frequencyBinCount);
            analyser.getByteFrequencyData(dataArray);

            const average = dataArray.reduce((a, b) => a + b, 0) / dataArray.length / 255;
            const now = Date.now();

            if (average > SILENCE_THRESHOLD) {
                lastSoundTime = now;
            }

            const silenceDuration = now - lastSoundTime;
            const recordingDuration = now - recordingStartTime;

            // For single field prompts, use silence detection
            // For main recording ('all' mode), only stop via button click
            if (currentMode === 'single') {
                if (silenceDuration > SILENCE_DELAY && recordingDuration > MIN_RECORDING_TIME) {
                    console.log('Silence detected, stopping field recording');
                    showStatus('ðŸ”„ Processing your speech...', 'info');
                    stopRecording();
                    return;
                }

                // Visual feedback for single field mode
                if (silenceDuration > 500 && silenceDuration < SILENCE_DELAY) {
                    const remaining = Math.ceil((SILENCE_DELAY - silenceDuration) / 1000);
                    showStatus(`ðŸŽ¤ Listening... (auto-stop in ${remaining}s of silence)`, 'info');
                }
            } else {
                // Main recording mode - show recording duration
                const seconds = Math.floor(recordingDuration / 1000);
                showStatus(`ðŸŽ¤ Recording... ${seconds}s (click Stop when done)`, 'info');
            }

            requestAnimationFrame(detectSilence);
        }

        // ============================================
        // Processing Functions
        // ============================================
        async function processFullRecording(audioBlob) {
            setStep('step-process');

            // Choose endpoint based on processing mode
            const endpoint = processingMode === 'single-stage' ? '/transcribe_multimodal' : '/transcribe';

            // Build mode label based on mode and backend
            let modeLabel;
            if (processingMode === 'single-stage') {
                const backendLabels = {
                    'openai': 'OpenAI GPT-4o',
                    'ollama': 'Ollama (Local)',
                    'vllm': 'vLLM (Local)'
                };
                modeLabel = `Single-stage (${backendLabels[selectedBackend]})`;
            } else {
                modeLabel = 'Two-stage (Whisper + Extraction)';
            }

            showStatus(`Processing with ${modeLabel}...`, 'info');

            const formData = new FormData();
            formData.append('audio', audioBlob, 'recording.webm');

            // Add backend parameter for single-stage mode
            if (processingMode === 'single-stage') {
                formData.append('backend', selectedBackend);
            }

            try {
                const response = await fetch(endpoint, {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();
                console.log('Transcription result:', result);

                if (response.ok && result.success) {
                    // Show transcript with method info
                    const preview = document.getElementById('transcriptPreview');
                    let methodInfo = '';
                    if (result.method === 'multimodal') {
                        const backendName = result.backend || selectedBackend;
                        methodInfo = ` [Single-Stage: ${backendName}]`;
                    } else {
                        methodInfo = ' [Two-Stage]';
                    }
                    preview.textContent = `"${result.transcript}"${methodInfo}`;
                    preview.classList.add('show');

                    // Fill fields
                    setStep('step-fill');
                    fillFieldsFromResult(result.form_data || {}, result.field_confidence || {});

                    // Check for missing fields
                    const missing = result.missing_fields || findMissingFields();

                    if (missing.length > 0) {
                        missingFieldsQueue = [...missing];
                        showStatus(`Filled ${FIELDS.length - missing.length} of ${FIELDS.length} fields. Let's capture the rest.`, 'warning');
                        promptNextMissingField();
                    } else {
                        showCompletion();
                    }
                } else {
                    // Show error message (no automatic fallback)
                    showStatus(result.error || 'Failed to process speech', 'error');
                }
            } catch (error) {
                console.error('Processing error:', error);
                showStatus('Error processing recording. Please try again.', 'error');
            }
        }

        function fillFieldsFromResult(formData, confidenceData = {}) {
            console.log('fillFieldsFromResult called with:', formData, confidenceData);
            FIELDS.forEach(field => {
                const value = formData[field];
                if (value && value.trim()) {
                    const normalized = normalizeFieldValue(field, value);
                    document.getElementById(field).value = normalized;

                    // Get confidence for this field (default to 0.7 instead of 1.0 to show indicator)
                    const confidence = confidenceData[field] !== undefined ? confidenceData[field] : 0.7;
                    console.log(`Field ${field}: value="${normalized}", confidence=${confidence}`);
                    updateFieldConfidence(field, confidence);

                    // Set appropriate state based on confidence
                    if (confidence < 0.5) {
                        setFieldState(field, 'low-confidence');
                    } else {
                        setFieldState(field, 'filled');
                    }
                }
            });
        }

        function updateFieldConfidence(fieldId, confidence) {
            console.log(`updateFieldConfidence: ${fieldId} = ${confidence}`);
            const indicator = document.getElementById(`confidence-${fieldId}`);
            const fill = document.getElementById(`confidence-fill-${fieldId}`);
            const text = document.getElementById(`confidence-text-${fieldId}`);

            console.log(`Elements found: indicator=${!!indicator}, fill=${!!fill}, text=${!!text}`);
            if (!indicator || !fill || !text) return;

            // Show confidence indicator
            indicator.classList.add('show');

            // Update bar width
            fill.style.width = `${confidence * 100}%`;

            // Update bar color based on confidence
            fill.classList.remove('high', 'medium', 'low');
            if (confidence >= 0.75) {
                fill.classList.add('high');
                text.textContent = 'High confidence';
            } else if (confidence >= 0.5) {
                fill.classList.add('medium');
                text.textContent = 'Medium confidence';
            } else {
                fill.classList.add('low');
                text.textContent = 'Low confidence - please verify';
            }
        }

        function hideFieldConfidence(fieldId) {
            const indicator = document.getElementById(`confidence-${fieldId}`);
            if (indicator) {
                indicator.classList.remove('show');
            }
        }

        function findMissingFields() {
            return FIELDS.filter(field => {
                const value = document.getElementById(field).value;
                return !value || !value.trim();
            });
        }

        // ============================================
        // Missing Field Prompts
        // ============================================
        function promptNextMissingField() {
            if (missingFieldsQueue.length === 0) {
                // All fields complete
                showCompletion();
                return;
            }

            const fieldId = missingFieldsQueue[0];
            currentPromptField = fieldId;

            // Mark remaining as missing
            missingFieldsQueue.forEach(f => setFieldState(f, 'missing'));

            // Show prompt for first missing field
            showFieldPrompt(fieldId);
            showStatus(`Please provide your ${fieldId}`, 'info');
        }

        async function recordForField(fieldId) {
            currentMode = 'single';
            currentPromptField = fieldId;

            hideFieldPrompt(fieldId);
            showStatus(`ðŸŽ¤ Listening for your ${fieldId}...`, 'info');

            try {
                stream = await navigator.mediaDevices.getUserMedia({
                    audio: { echoCancellation: true, noiseSuppression: true }
                });

                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                const source = audioContext.createMediaStreamSource(stream);
                source.connect(analyser);
                analyser.fftSize = 512;

                mediaRecorder = new MediaRecorder(stream, {
                    mimeType: 'audio/webm;codecs=opus'
                });

                audioChunks = [];
                isRecording = true;
                recordingStartTime = Date.now();
                lastSoundTime = Date.now();

                mediaRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) {
                        audioChunks.push(e.data);
                        // Send chunk to server for real-time processing
                        socket.emit('audio_chunk', e.data);
                    }
                };

                mediaRecorder.onstop = async () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    await processFieldRecording(audioBlob, currentPromptField);
                    cleanupRecording();
                };

                mediaRecorder.start(100);
                detectSilence();

            } catch (error) {
                console.error('Field recording failed:', error);
                showStatus('Microphone error. Please try again.', 'error');
                showFieldPrompt(fieldId);
            }
        }

        async function processFieldRecording(audioBlob, fieldId) {
            showStatus(`ðŸ”„ Processing ${fieldId}...`, 'info');

            const formData = new FormData();
            formData.append('audio', audioBlob, 'recording.webm');

            try {
                const response = await fetch('/transcribe_simple', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();
                console.log('Field transcription:', result);

                if (response.ok && result.success && result.transcript) {
                    const input = document.getElementById(fieldId);
                    const normalized = normalizeFieldValue(fieldId, result.transcript);
                    input.value = normalized;
                    setFieldState(fieldId, 'filled');
                    hideFieldPrompt(fieldId);

                    // Show confidence indicator for field-specific recording
                    // Use 0.75 as default since single-field recording is targeted
                    updateFieldConfidence(fieldId, 0.75);

                    // Remove from queue and continue
                    missingFieldsQueue = missingFieldsQueue.filter(f => f !== fieldId);

                    if (missingFieldsQueue.length > 0) {
                        showStatus(`Got it! ${missingFieldsQueue.length} field(s) remaining.`, 'success');
                        setTimeout(() => promptNextMissingField(), 500);
                    } else {
                        showCompletion();
                    }
                } else {
                    showStatus('Could not capture that. Please try again.', 'warning');
                    showFieldPrompt(fieldId);
                }
            } catch (error) {
                console.error('Field processing error:', error);
                showStatus('Error processing. Please try again.', 'error');
                showFieldPrompt(fieldId);
            }
        }

        function skipField(fieldId) {
            hideFieldPrompt(fieldId);
            setFieldState(fieldId, '');

            // Remove from queue
            missingFieldsQueue = missingFieldsQueue.filter(f => f !== fieldId);

            if (missingFieldsQueue.length > 0) {
                promptNextMissingField();
            } else {
                // Check if any fields have values
                const filledCount = FIELDS.filter(f => document.getElementById(f).value.trim()).length;
                if (filledCount > 0) {
                    showCompletion();
                } else {
                    showStatus('Form is empty. Click "Start Recording" to try again.', 'warning');
                    setStep('step-record');
                }
            }
        }

        // ============================================
        // Reset Function
        // ============================================
        function resetForm() {
            // Clear all inputs
            FIELDS.forEach(field => {
                document.getElementById(field).value = '';
                setFieldState(field, '');
                hideFieldPrompt(field);
                hideFieldConfidence(field);
            });

            // Reset state
            missingFieldsQueue = [];
            currentPromptField = null;
            currentMode = 'all';

            // Reset UI
            document.getElementById('transcriptPreview').classList.remove('show');
            document.getElementById('completion').classList.remove('show');
            hideStatus();
            setStep('step-record');

            cleanupRecording();
        }

        // ============================================
        // Manual Input Support
        // ============================================
        FIELDS.forEach(field => {
            const input = document.getElementById(field);
            input.addEventListener('input', () => {
                if (input.value.trim()) {
                    setFieldState(field, 'filled');

                    // If this was the prompted field, move to next
                    if (currentPromptField === field) {
                        hideFieldPrompt(field);
                        missingFieldsQueue = missingFieldsQueue.filter(f => f !== field);

                        if (missingFieldsQueue.length > 0) {
                            setTimeout(() => promptNextMissingField(), 300);
                        } else {
                            showCompletion();
                        }
                    }
                } else {
                    setFieldState(field, '');
                }
            });
        });

        // Initialize
        setStep('step-record');
    </script>
</body>

</html>